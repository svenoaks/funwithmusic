/* Gracenote Android Music SDK Sample Application
 *
 * Copyright (C) 2010 Gracenote, Inc. All Rights Reserved.
 */

package com.customer.example;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Timer;
import java.util.TimerTask;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.provider.Settings;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageView;
import android.widget.TextView;

import com.gracenote.mmid.MobileSDK.GNAlbumIDFileError;
import com.gracenote.mmid.MobileSDK.GNAudioSourceDelegate;
import com.gracenote.mmid.MobileSDK.GNAudioSourceMic;
import com.gracenote.mmid.MobileSDK.GNAlbumIDSearchResult;
import com.gracenote.mmid.MobileSDK.GNAudioConfig;
import com.gracenote.mmid.MobileSDK.GNCacheStatusEnum;
import com.gracenote.mmid.MobileSDK.GNConfig;
import com.gracenote.mmid.MobileSDK.GNImage;
import com.gracenote.mmid.MobileSDK.GNOperationStatusChanged;
import com.gracenote.mmid.MobileSDK.GNOperations;
import com.gracenote.mmid.MobileSDK.GNRecognizeStream;
import com.gracenote.mmid.MobileSDK.GNSampleBuffer;
import com.gracenote.mmid.MobileSDK.GNSearchResponse;
import com.gracenote.mmid.MobileSDK.GNSearchResult;
import com.gracenote.mmid.MobileSDK.GNSearchResultReady;
import com.gracenote.mmid.MobileSDK.GNStatus;
import com.gracenote.mmid.MobileSDK.GNStatusEnum;

/**
 * <p>
 * This reference application introduces the basic coding techniques for
 * accessing Gracenote's file and stream-based fingerprinting technology.
 * File-based fingerprints are generated by clicking the "Update Files" button.
 * Real-time stream-based fingerprints are generated by clicking the "Listen"
 * button. To show how Gracenote can fingerprint local files, the reference
 * application reads .wav files stored stored on the local sdCard in the
 * /sdcard/gracenote/ directory. To show Gracenote's live audio stream
 * recognition, audio is recorded from the Android device's microphone.
 * </p>
 * 
 * <p>
 * Once audio has been retrieved from a file or microphone, the audio data is
 * passed to Gracenote's native fingerprinting utility which rapidly creates a
 * unique fingerprint of the audio. This audio is then passed to Gracenote's web
 * service for lookup and retrieval of the corresponding audio's meta data
 * (including cover art if present).
 * </p>
 * 
 * <p>
 * To provide a realistic reference, this application performs fingerprinting
 * and network lookups on a separate thread. By performing these tasks on a
 * separate thread, immediate feedback is provided on the speed at which these
 * processes take place.
 * </p>
 * 
 * <p>
 * NOTE: As in all UI-based applications, UI updates must occur on the main
 * thread. To accomplish this in the Android environment, threaded actions are
 * performed using {@link AsyncTask} which has the built-in ability to handle UI
 * update calls to ensure they are processed on the main UI thread.
 * </p>
 * 
 */
public class GracenoteMusicID extends Activity {

	private TextView statusText;
	private Button buttonMic, buttonFiles, buttonPCMStream;
	private Button buttonText, buttonLyricFragment, buttonHistory,
			buttonAlbumID,buttonCancel;
	//private GNAudioConfig audioConfig;

	private CheckBox checkboxDebug;
	private ViewGroup metadataListing;
	private int metadataNumImagesRendered = 0;
	private int metadataMaxNumImages = 10;
	List<String> filenameslist = new ArrayList<String>();
	
	GNRecognizeStreamOperationTask gNRecognizeStreamOperationTask;
	private GNConfig config;
	int i = 0;

	private ArrayList<GNSearchResultReady> listOfOperations;
	private ProgressDialog dialog;
	private final String LOG_TAG="GracenoteMusicID";

	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		try {
			// You have been issued a Gracenote Client ID from Gracenote Professional Services.
			// Use Client ID in [ClientID]-[ClientID Tag] form.
			createUI();
			config = GNConfig.init("319488-635BB867F4A29641894975ACAED21413", this.getApplicationContext());
			this.config.setProperty("debugenabled", "0");
			updateStatus("GNSDK version: " + config.getProperty("version"),true);
			listOfOperations = new ArrayList<GNSearchResultReady>();

			gNRecognizeStreamOperationTask = new GNRecognizeStreamOperationTask();

			// Call loadCache in background thread.  
			setUpCache();

		} catch (Exception e) {
			gNRecognizeStreamOperationTask = null;
			Log.e(LOG_TAG, e.toString());
			if (e != null) {
				updateStatus(e.toString(), true);	
			} 
			buttonCancel.setEnabled(false);
			setUIEnabled(false);
		}
	}

    
    @Override
	protected void onPostResume() {
		super.onPostResume();
			
		clearErrorMsg();
		
        if (gNRecognizeStreamOperationTask != null) {
            gNRecognizeStreamOperationTask.startOperation();
        }
		        
    }
    

	@Override
	protected void onPause() {
		super.onPause();
		if (gNRecognizeStreamOperationTask != null) {
			gNRecognizeStreamOperationTask.stopOperation();
		}
	}

	
	@Override
	protected void onDestroy() {
		super.onDestroy();
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		// TODO Auto-generated method stub
		if (keyCode == KeyEvent.KEYCODE_BACK) {
			if (gNRecognizeStreamOperationTask != null) {
				gNRecognizeStreamOperationTask.stopOperation();
			}
		}
		return super.onKeyDown(keyCode, event);
	}

	private void setUpCache() {

		new Thread(new Runnable() {
			public void run() {
				try {
					InputStream in = getResources().openRawResource(R.raw.bundle161);
					final String bundleFilePath = Environment.getExternalStorageDirectory().getAbsolutePath() + "/bundle161.b";
					FileOutputStream out = new FileOutputStream(bundleFilePath);
					byte[] buff = new byte[1024];
					int read = 0;
					try {
						while ((read = in.read(buff)) > 0) {
							out.write(buff, 0, read);
						}
					} finally {
						in.close();
						out.close();
					}

					GNCacheStatusEnum cacheStatus = config.loadCache(bundleFilePath);
					if(cacheStatus != GNCacheStatusEnum.SUCCESS){
						Log.e(LOG_TAG, "load cache failed with status: " + cacheStatus.toString());
					}

					// Delete Bundle after loading cache
					File bundlefile = new File(bundleFilePath);
					if (bundlefile.exists()) {
						bundlefile.delete();
					}

				} catch (Exception e) {
					Log.e(LOG_TAG, e.toString());
				}
			}
		}).start();
	}

	private void createUI() {
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.main);

		buttonMic = (Button) findViewById(R.id.buttonIdNow);
		buttonMic.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				// Disable buttons to prevent duplicate requests so we can avoid
				// error handling and cancellation of fingerprinting
				setUIEnabled(false);
				clearResults();
				gNRecognizeStreamOperationTask.idNow();
			}
		});

		buttonAlbumID = (Button) findViewById(R.id.buttonAlbumID);
		buttonAlbumID.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				setUIEnabled(false);
				clearResults();

				RecognizeDirectoryForAlbumTask task = new RecognizeDirectoryForAlbumTask();
				task.recognizeDirectoryForAlbum(Environment.getExternalStorageDirectory().getAbsolutePath() + "/gracenote/");
			}
		});

		buttonFiles = (Button) findViewById(R.id.buttonFiles);
		buttonFiles.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {

				boolean hasFiles = false;
				File sdcard = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/gracenote");
				if (sdcard.exists()) {
					String[] filenames = sdcard.list();
					for (String filename : filenames) {
						// Perform simple test for presence of supported music
						// files. Alert user if none are present.
						String lowerCaseFilePath = filename.toLowerCase();

						if (lowerCaseFilePath.endsWith(".wav")
								|| lowerCaseFilePath.endsWith(".mp3")
								|| lowerCaseFilePath.endsWith(".mp4")
								|| lowerCaseFilePath.endsWith(".m4a")
								|| lowerCaseFilePath.endsWith(".3gp")
								|| lowerCaseFilePath.endsWith(".3gpp")
								|| lowerCaseFilePath.endsWith(".3gpp2")
								|| lowerCaseFilePath.endsWith(".3g2")) {
							hasFiles = true;
							break;
						}
					}
				}

				if (hasFiles) {
					// Disable buttons to prevent duplicate requests so we can
					// avoid error handling and cancellation of fingerprinting
					setUIEnabled(false);
				}
				clearResults();
				RecognizeFilesTask task = new RecognizeFilesTask();
				task.execute();
			}
		});

		buttonPCMStream = (Button) findViewById(R.id.buttonPCMStream);
		buttonPCMStream.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {

				// Disable buttons to prevent duplicate requests so we can avoid
				// error handling and cancellation of fingerprinting
				setUIEnabled(false);

				clearResults();
				RecognizePCMStreamTask task = new RecognizePCMStreamTask();
				task.recognizePCMStream();
			}

		});

		checkboxDebug = (CheckBox) findViewById(R.id.checkboxDebug);
		checkboxDebug
				.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
					public void onCheckedChanged(CompoundButton buttonView,
							boolean isChecked) {
						if (isChecked) {
							config.setProperty("debugEnabled", "1");
						} else {
							config.setProperty("debugEnabled", "0");
						}
						
						if(gNRecognizeStreamOperationTask!=null){
							gNRecognizeStreamOperationTask.onConfigChanged(config);
						}
					}
				});

		buttonText = (Button) findViewById(R.id.buttonText);
		buttonText.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				AlertDialog.Builder alert = new AlertDialog.Builder(
						GracenoteMusicID.this);

				alert.setTitle("Text Search");
				alert.setMessage("Enter 1 to 3 fields");

				LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				final View textSearchView = inflater.inflate(
						R.layout.text_search, null);

				alert.setView(textSearchView);

				alert.setPositiveButton("Ok",
						new DialogInterface.OnClickListener() {
							public void onClick(DialogInterface dialog,
									int whichButton) {
								TextView artistTextView = (TextView) textSearchView
										.findViewById(R.id.TextArtist);
								String artist = artistTextView.getText()
										.toString();
								TextView albumTextView = (TextView) textSearchView
										.findViewById(R.id.TextAlbum);
								String album = albumTextView.getText()
										.toString();
								TextView trackTextView = (TextView) textSearchView
										.findViewById(R.id.TextTrack);
								String track = trackTextView.getText()
										.toString();

								// Disable buttons to prevent another request
								// while this one is running
								setUIEnabled(false);
								clearResults();

								TextSearchTask task = new TextSearchTask();
								task.textSearch(artist, album, track);
							}
						});

				alert.setNegativeButton("Cancel", null);

				alert.show();
			}
		});

		buttonHistory = (Button) findViewById(R.id.buttonHistory);
		buttonHistory.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				startActivity(new Intent(GracenoteMusicID.this, HistoryDetails.class));
			}
		});
		buttonLyricFragment = (Button) findViewById(R.id.buttonLyricFragment);
		buttonLyricFragment.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				AlertDialog.Builder alert = new AlertDialog.Builder(
						GracenoteMusicID.this);

				alert.setTitle("Lyric Fragment Search");
				alert.setMessage("Enter Lyrics (Artist optional)");

				LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				final View lyricFragmentSearchView = inflater.inflate(
						R.layout.lyric_fragment_search, null);

				alert.setView(lyricFragmentSearchView);

				alert.setPositiveButton("Ok",
						new DialogInterface.OnClickListener() {
							public void onClick(DialogInterface dialog,
									int whichButton) {
								TextView artistTextView = (TextView) lyricFragmentSearchView
										.findViewById(R.id.LyricFragmentArtist);
								String artist = artistTextView.getText()
										.toString();
								TextView lyricFragmentTextView = (TextView) lyricFragmentSearchView
										.findViewById(R.id.LyricFragment);
								String lyricFragment = lyricFragmentTextView
										.getText().toString();

								// Disable buttons to prevent another request
								// while this one is running
								setUIEnabled(false);
								clearResults();

								LyricFragmentSearchTask task = new LyricFragmentSearchTask();
								task.lyricFragmentSearch(artist, lyricFragment);
							}
						});

				alert.setNegativeButton("Cancel", null);

				alert.show();
			}
		});

		buttonCancel = (Button) findViewById(R.id.buttoncancel);
		buttonCancel.setOnClickListener(new OnClickListener() {

			public void onClick(View v) {
				// TODO Auto-generated method stub
				cancelAllOpertaions();
			}
		});

		metadataListing = (ViewGroup) findViewById(R.id.metadataListing);

		statusText = (TextView) findViewById(R.id.statusText);
	}

	/**
	 * Show current status of audio fingerprinting process.
	 */
	private void updateStatus(String status, boolean clearStatus) {
		statusText.setVisibility(View.VISIBLE);
		if (clearStatus) {
			statusText.setText(status);
		} else {
			statusText.setText((String) statusText.getText() + "\n" + status);
		}
	}

	/**
	 * Clear error message.
	 */	
	private void clearErrorMsg(){
		if(!statusText.getText().toString().contains("GNSDK version")){
			statusText.setText("");
		}
		buttonMic.setError(null);
	}
	

	/**
	 * Reset UI according to input value.
	 */
	private void setUIEnabled(boolean inValue) {
		// We can now re-enable buttons
		buttonMic.setEnabled(inValue);
		buttonFiles.setEnabled(inValue);
		buttonText.setEnabled(inValue);
		buttonLyricFragment.setEnabled(inValue);
		buttonPCMStream.setEnabled(inValue);
		checkboxDebug.setEnabled(inValue);
		buttonHistory.setEnabled(inValue);
		buttonAlbumID.setEnabled(inValue);
	}

	/**
	 * Clears the results of the prior file fingerprinting lookups or microphone
	 * audio lookups.
	 */

	private void clearResults() {
		statusText.setText("");
		metadataListing.removeAllViews();
		this.metadataNumImagesRendered = 0;
	}

	public OnClickListener albumListener = new OnClickListener() {
		public void onClick(View v) {
			if (v.getTag() != "") {
				// Disable buttons to prevent duplicate requests so we can avoid
				// error handling and cancellation of fingerprinting
				setUIEnabled(false);
				/**
				 * Currently Album ID is passed, it should be Track ID. TODO -
				 * Track ID is needs to be replaced with Album ID
				 */
				clearResults();
				TrackSearchTask task = new TrackSearchTask();
				task.trackSearch((String) v.getTag());
			}
		}
	};

	/**
	 * Adds a new row of audio details including cover art to the UI for a
	 * GNSearchResponse result from the SDK. If the lookup was successful but
	 * failed to match a known track, then this method will be invoked with a
	 * null argument. This method is not invoked in the error case.
	 */
	private void updateMetaDataFields(final GNSearchResponse bestResponse,
			boolean displayNoCoverArtAvailable, boolean fromTxtOrLyricSearch) {
		// Load metadata layout from resource .xml
		LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		View metadataView = inflater.inflate(R.layout.file_meta_data, null);
		metadataView.setClickable(true);
		metadataView.setOnClickListener(albumListener);

		metadataListing.addView(metadataView, 0);

		final ImageView coverArtImage = (ImageView) metadataView
				.findViewById(R.id.coverArtImage);

		TextView albumText = (TextView) metadataView
				.findViewById(R.id.albumName);
		TextView trackText = (TextView) metadataView
				.findViewById(R.id.trackTitle);
		TextView artistText = (TextView) metadataView
				.findViewById(R.id.artistName);

		final Button bioBtn = (Button) metadataView.findViewById(R.id.bioBtn);
		final Button reviewBtn = (Button) metadataView
				.findViewById(R.id.reviewBtn);

		if (displayNoCoverArtAvailable == false) {
		}

		if (fromTxtOrLyricSearch == false) {
			bioBtn.setVisibility(View.VISIBLE);
			reviewBtn.setVisibility(View.VISIBLE);
		} else {
			bioBtn.setVisibility(View.GONE);
			reviewBtn.setVisibility(View.GONE);
		}

		if (bestResponse == null) {
			coverArtImage.setVisibility(View.GONE);
			albumText.setVisibility(View.GONE);
			trackText.setVisibility(View.GONE);
			bioBtn.setVisibility(View.GONE);
			reviewBtn.setVisibility(View.GONE);
			// Use the artist text field to display the error message
			artistText.setText("Music Not Identified");
		} else {
			// The GUI can't display an unlimited number of images because
			// we would run out of memory before long. Once the max number
			// of images has been rendered, just treat the rest as "no cover"
			boolean maxNumImagesAlreadyRendered = false;
			if (this.metadataNumImagesRendered++ >= this.metadataMaxNumImages) {
				maxNumImagesAlreadyRendered = true;
			}

			if (!maxNumImagesAlreadyRendered && bestResponse.getCoverArt() != null) {
				// JPEG image data provided inline in the response
				GetCoverArtImage getCoverArtImage = new GetCoverArtImage(
						new Observer() {
							public void update(Observable observable, Object data) {
								if (data != null) {
									byte[] image = (byte[]) data;
									ByteArrayInputStream is = new ByteArrayInputStream(image);
									Drawable coverArt = Drawable.createFromStream(is, "src");

									if (coverArt != null) {
										coverArtImage.setImageDrawable(coverArt);
									} else {
										coverArtImage.setImageDrawable((getResources().getDrawable(R.drawable.no_cover_art)));
									}
								}
							}
						});
				getCoverArtImage.execute(bestResponse);
			} else {
				// JPEG image data not found in the webservices response
				coverArtImage.setVisibility(View.GONE);
			}

			albumText.setText(bestResponse.getAlbumTitle());
			artistText.setText(bestResponse.getArtist());
			trackText.setText(bestResponse.getTrackTitle());
			metadataView.setTag(bestResponse.getTrackId());

			/**
			 * Handle Artist Details & Album Review Button's click
			 **/
			bioBtn.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					dialog = ProgressDialog.show(GracenoteMusicID.this,
							"Please Wait..", "Retrieving Information...");
					GetArtistBiography getArtistBiography = new GetArtistBiography(
							new Observer() {
								public void update(Observable observable,
										Object data) {
									dialog.cancel();
									DataHolder myData = (DataHolder) data;
									Intent intent = new Intent(GracenoteMusicID.this, BioReviewActivity.class);
									intent.putExtra("type", "bio");
									intent.putExtra("data", myData.myData);
									if (myData.myImage != null) {
										intent.putExtra("cover_art", myData.myImage);
									}
									intent.putExtra("album", bestResponse.getAlbumTitle());
									intent.putExtra("artist", bestResponse.getArtist());
									startActivityForResult(intent, 1);
								}
							});
					getArtistBiography.execute(bestResponse);
				}
			});

			reviewBtn.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					dialog = ProgressDialog.show(GracenoteMusicID.this,
							"Please Wait..", "Retrieving Information...");
					GetAlbumReview getAlbumReview = new GetAlbumReview(
							new Observer() {
								public void update(Observable observable,
										Object data) {
									dialog.cancel();
									String resultData = (String) data;
									Intent intent = new Intent(
											GracenoteMusicID.this,
											BioReviewActivity.class);
									intent.putExtra("type", "review");
									intent.putExtra("data", resultData);
									if (bestResponse.getCoverArt() != null)
										intent.putExtra("cover_art", bestResponse.getCoverArt() .getData());
									intent.putExtra("album", bestResponse.getAlbumTitle());
									intent.putExtra("artist", bestResponse.getArtist());
									startActivityForResult(intent, 1);
								}
							});
					getAlbumReview.execute(bestResponse);
				}
			});

			updateStatus("", true); // clear status
		}
	}

	class DataHolder {
		String myData;
		byte[] myImage;
	}

	/**
	 * This class will be used to perform GNRecognizeStream operation.
	 */

	class GNRecognizeStreamOperationTask implements GNSearchResultReady, GNOperationStatusChanged, GNAudioSourceDelegate{

		GNRecognizeStream gnRecognizePCM = null;
		GNAudioSourceMic gnAudioSourceMic = null;
		GNAudioConfig audioConfig = null;

		public GNRecognizeStreamOperationTask() throws Exception {
			// TODO Auto-generated constructor stub

			int sampleRate = 44100;
			int bytesPerSample = 2;
			int numChannels = 1;
			this.audioConfig = new GNAudioConfig(sampleRate, bytesPerSample, numChannels);
			this.gnRecognizePCM = new GNRecognizeStream(config);
			this.gnAudioSourceMic = new GNAudioSourceMic(this.audioConfig, this);
		}

		public void startOperation() {
			this.gnRecognizePCM.startSession(this, audioConfig);
			try {
				if(this.gnAudioSourceMic == null){
					this.gnAudioSourceMic = new GNAudioSourceMic(this.audioConfig,this);
				}
				this.gnAudioSourceMic.startRecording();
			}
			catch(Exception e){
				//audio-recording initialization failed
				e.printStackTrace();
				stopOperation();
				updateStatusOnMainThread("Error: Unable to get input from microphone. ID-Now will fail.");
				buttonMic.setError("Invalid operation");
			}
			setUIEnabled(true);
		}

		public void idNow() {
			if (this.gnRecognizePCM != null) {
				this.gnRecognizePCM.idNow();
			}
		}

		public void cancelIdNow() {
			if (this.gnRecognizePCM != null) {
				this.gnRecognizePCM.cancelIdNow();
			}
		}

		public void stopOperation() {

			if (this.gnAudioSourceMic != null) {
				this.gnAudioSourceMic.stopRecording();
			}

			this.gnRecognizePCM.stopSession();
			//clearResults();
		}

		public void audioBufferReady(byte[] samples, boolean audioInputError) {
			if(audioInputError){
				updateStatusOnMainThread("Unable to get input from microphone. ID-Now will fail.");
			}
			else {
				this.gnRecognizePCM.writeBytes(samples);
			}
			
		}

		protected void onConfigChanged(GNConfig config){
			
			gnRecognizePCM.stopSession();
			gnRecognizePCM=null;
			gnRecognizePCM=new GNRecognizeStream(config);
			gnRecognizePCM.startSession(this, audioConfig);
			
		}
		
		public void GNStatusChanged(GNStatus status) {
			// TODO Auto-generated method stub
			updateStatusOnMainThread(status);
		}

		public void GNResultReady(GNSearchResult result) {
			// TODO Auto-generated method stub
			updateResultScreenOnMainThread(result);
		}
	}

	/**
	 * This class will be used to fetch Artist Biography asynchronously using
	 * Observer pattern.
	 */
	class GetArtistBiography extends AsyncTask<GNSearchResponse, Integer, Long> {

		GNSearchResponse bestResponse;
		DelegatedObservable obs = new DelegatedObservable();
		String strArtistBio = "";
		DataHolder data = new DataHolder();

		public GetArtistBiography(Observer o) {
			super();
			obs.addObserver(o);
		}

		@Override
		protected Long doInBackground(GNSearchResponse... params) {
			bestResponse = (GNSearchResponse) params[0];
			String[] artistBioGraphy = bestResponse.getArtistBiography();

			if (artistBioGraphy != null && artistBioGraphy.length > 0) {
				for (int k = 0; k < artistBioGraphy.length; k++) {
					strArtistBio += artistBioGraphy[k] + "\n";
				}
			}
			data.myData = strArtistBio;
			try {
				GNImage contributorGNImage = bestResponse.getContributorImage();
				data.myImage = contributorGNImage.getData();
				// deprecated
				// data.myImage = bestResponse.getArtistImage();
			} catch (Exception e) {
			}
			return null;
		}

		@Override
		protected void onPostExecute(Long result) {
			obs.setChanged();
			obs.notifyObservers(data);
		}

		/**
		 * @author Observable class
		 */
		class DelegatedObservable extends Observable {
			public void clearChanged() {
				super.clearChanged();
			}

			public void setChanged() {
				super.setChanged();
			}
		}
	}

	/**
	 * This class will be used to fetch Album Review asynchronously using
	 * Observer pattern.
	 */
	class GetAlbumReview extends AsyncTask<GNSearchResponse, Integer, Long> {

		GNSearchResponse bestResponse;
		DelegatedObservable obs = new DelegatedObservable();
		String strAlbumReview = "";

		public GetAlbumReview(Observer o) {
			super();
			obs.addObserver(o);
		}

		@Override
		protected Long doInBackground(GNSearchResponse... params) {
			bestResponse = (GNSearchResponse) params[0];
			String[] albumReview = bestResponse.getAlbumReview();

			if (albumReview != null && albumReview.length > 0) {
				for (int k = 0; k < albumReview.length; k++) {
					strAlbumReview += albumReview[k] + "\n";
				}
			}
			return null;
		}

		@Override
		protected void onPostExecute(Long result) {
			obs.setChanged();
			obs.notifyObservers(strAlbumReview);

		}

		/**
		 * @author Observable class
		 */
		class DelegatedObservable extends Observable {
			public void clearChanged() {
				super.clearChanged();
			}

			public void setChanged() {
				super.setChanged();
			}
		}
	}

	/**
	 * get COverart Image
	 * */

	class GetCoverArtImage extends AsyncTask<GNSearchResponse, Integer, byte[]> {

		GNSearchResponse bestResponse;
		DelegatedObservable obs = new DelegatedObservable();
		byte[] response;

		public GetCoverArtImage(Observer o) {
			super();
			obs.addObserver(o);
		}

		@Override
		protected byte[] doInBackground(GNSearchResponse... params) {
			bestResponse = (GNSearchResponse) params[0];
			response = bestResponse.getCoverArt().getData();
			return response;
		}

		@Override
		protected void onPostExecute(byte[] result) {
			obs.setChanged();
			obs.notifyObservers(response);
		}

		/**
		 * @author Observable class
		 */
		class DelegatedObservable extends Observable {
			public void clearChanged() {
				super.clearChanged();
			}

			public void setChanged() {
				super.setChanged();
			}
		}
	}

	/**
	 * search for album metadata from directory.
	 */
	private class RecognizeDirectoryForAlbumTask implements
			GNSearchResultReady, GNOperationStatusChanged {

		public void recognizeDirectoryForAlbum(String dirPath) {
			GNOperations.albumIdDirectory(this, config, dirPath);
			listOfOperations.add((GNSearchResultReady) this);
		}

		public void GNResultReady(GNSearchResult result) {
			listOfOperations.remove((GNSearchResultReady) this);
			GNAlbumIDSearchResult albumIdResult;

			if (result instanceof GNAlbumIDSearchResult) {

				if (result.isFailure()) {
					// An error occurred so display the error to the user.
					String msg = String.format("[%d] %s", result.getErrCode(),
							result.getErrMessage());
					updateStatus(msg, false);
					// Display error while leaving the
					// prior status update
				} else {
					albumIdResult = (GNAlbumIDSearchResult) result;

					GNSearchResponse[] responses = albumIdResult.getResponses();

					if (albumIdResult.isFailure()) {
						for (GNAlbumIDFileError fileErrorResponses : albumIdResult
								.getErrorResponses()) {
							Log.i("Error_Files",
									"File " + fileErrorResponses.getFileIdent()
											+ ": ErrorMessage: "
											+ fileErrorResponses.getErrMessage());
						}
						// An error occurred so display the error to the user.
						String msg = String.format("[%d] %s",
								result.getErrCode(), result.getErrMessage());
						updateStatus(msg, false);
						// Display error while leaving the prior status update
					} else {
						if (albumIdResult.isAlbumIdPartialFailure()) {
							for (GNSearchResponse gnSearchResponse : responses) {
								updateMetaDataFields(gnSearchResponse, true,
										false);
							}

							for (String no_matchresponse : albumIdResult
									.getNoMatchResponses()) {
								Log.i("No_Match", "File " + no_matchresponse);
							}

							for (GNAlbumIDFileError fileErrorResponses : albumIdResult
									.getErrorResponses()) {
								Log.i("Error_Files", "File "
										+ fileErrorResponses.getFileIdent()
										+ ": ErrorMessage: "
										+ fileErrorResponses.getErrMessage());
							}
							updateStatus("Success", true);
						} else if (albumIdResult.isAlbumIdNoMatchStatus()) {
							// Handle special case of albumId lookup with no
							// match
							for (String no_matchresponse : albumIdResult
									.getNoMatchResponses()) {
								Log.i("No_Match", "File " + no_matchresponse);
							}
							updateMetaDataFields((GNSearchResponse) null, true,
									false);
						} else {
							for (GNSearchResponse gnSearchResponse : responses) {
								updateMetaDataFields(gnSearchResponse, true,
										false);
							}
						}
						updateStatus("Success", true);
					}
				}
				setUIEnabled(true);
			}

		}

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}

	}

	/**
	 * Fingerprint sample.pcm files stored in /res/raw/. Then, create a
	 * fingerprint and search for song metadata.
	 */
	public class RecognizePCMStreamTask implements GNSearchResultReady,
			GNOperationStatusChanged {

		private GNSampleBuffer loadSamplePCM() {
			int channel = 1;
			int sampleRate = 8000;
			int length = (int) (channel * sampleRate * 2 * 6.5);

			InputStream is = getResources().openRawResource(R.raw.sample);

			byte[] pcmBuffer = new byte[length];

			try {
				DataInputStream dataIn = new DataInputStream(is);
				dataIn.read(pcmBuffer, 0, length);
				dataIn.close();
			} catch (IOException e) {
				pcmBuffer = null;
			}

			return new GNSampleBuffer(pcmBuffer, channel, sampleRate);
		}

		public void recognizePCMStream() {
			GNSampleBuffer samplePCMBuffer = loadSamplePCM();
			GNOperations.recognizeMIDStreamFromPcm(this, config, samplePCMBuffer);
			listOfOperations.add((GNSearchResultReady) this);

		}

		/**
		 * When the fingeprint/lookup operation is finished, this method will be
		 * invoked in the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			listOfOperations.remove((GNSearchResultReady) this);
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isFingerprintSearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, true, false);
				} else {
					GNSearchResponse bestResponse = result.getBestResponse();
					// Inserting search result into database.
					synchronized (result) {
						trackChanges(result);
					}
					updateMetaDataFields(bestResponse, true, false);
				}
				updateStatus("Success", true);
			}

			setUIEnabled(true);
		}

		/**
		 * Intermediate status update from the fingerprinter
		 */

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}
	}

	/**
	 * Fingerprint files stored in external storage directory under /gracenote
	 * subfolder. For each file, create a fingerprint and search for song metadata.
	 * A secondary task thread is used since iterating through a large number of files
	 * could take some time.
	 */
	public class RecognizeFilesTask extends AsyncTask<Object, Object, String> {
		private int numFilesToFingerprint = 0;

		private boolean isSupportedFormat(String filename) {

			String lowerCaseFilePath = filename.toLowerCase();
			return (lowerCaseFilePath.endsWith(".wav")
					|| lowerCaseFilePath.endsWith(".mp3")
					|| lowerCaseFilePath.endsWith(".mp4")
					|| lowerCaseFilePath.endsWith(".m4a")
					|| lowerCaseFilePath.endsWith(".3gp")
					|| lowerCaseFilePath.endsWith(".3gpp")
					|| lowerCaseFilePath.endsWith(".3gpp2") || lowerCaseFilePath
					.endsWith(".3g2"));
		}

		protected String doInBackground(Object... objects) {
			String resultMsg = null;
			// Process any supported files stored in the /sdcard/gracenote/
			// directory.
			boolean hasFiles = false;
			File sdcard = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/gracenote");
			if (sdcard.exists()) {
				String[] filenames = sdcard.list();
				for (String filename : filenames) {
					// Perform simple test for presence of supported music
					// files. Alert user if none are present.
					if (isSupportedFormat(filename)) {
						hasFiles = true;
						break;
					}
				}
				if (hasFiles) {

					for (String filename : filenames) {
						if (isSupportedFormat(filename)) {
							File file = new File(sdcard, filename);
							String filePath = file.getAbsolutePath();
							RecognizeFileOperation op = new RecognizeFileOperation(
									this, filename);
							GNOperations.recognizeMIDFileFromFile(op, config,
									filePath);
							numFilesToFingerprint++;
						}
					}
				} else {
					resultMsg = "No supported music files were found on the sdCard.  Please install files in the /sdcard/gracenote/ directory of your device or emulator.";
				}
			} else {
				resultMsg = "Put music files into /sdcard/gracenote/ directory of your device or emulator.";
			}

			return resultMsg;
		}

		/**
		 * Update UI with result message results on GUI thread
		 */
		protected void onPostExecute(String resultMsg) {
			if (resultMsg != null) {
				// Task did not start any fingerprint operations
				updateStatus(resultMsg, true);
			}
		}

		/**
		 * When the fingeprint/lookup operation is finished, this method will be
		 * invoked in the UI thread to report results.
		 */

		public void doneWithFile(String filename) {
			// If done with all the operations, enable the buttons again

			if (--numFilesToFingerprint == 0) {
				setUIEnabled(true);
			}
		}
	}

	/**
	 * Implements an object that associates a specific named .wav file with the
	 * operation that recognizes that specific file.
	 */

	class RecognizeFileOperation implements GNSearchResultReady,
			GNOperationStatusChanged {
		private RecognizeFilesTask task;
		private String filePath; // fully qualified name of file getting

		// recognized

		RecognizeFileOperation(RecognizeFilesTask inTask, String inFilePath) {
			listOfOperations.add((GNSearchResultReady) this);
			this.task = inTask;
			this.filePath = inFilePath;
		}

		/**
		 * When the fingeprint/lookup operation is finished, this method will be
		 * invoked in the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			listOfOperations.remove((GNSearchResultReady) this);
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isFingerprintSearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, true, false);
				} else {
					GNSearchResponse bestResponse = result.getBestResponse();
					updateMetaDataFields(bestResponse, true, false);
				}
				updateStatus("Success", true);
			}

			// If done with operation, enable the buttons again

			task.doneWithFile(filePath);
		}

		/**
		 * Intermediate status update from the fingerprinter
		 */

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}
	}

	/**
	 * Listen on the device's microphone and create an audio fingerprint for
	 * lookup by Gracenote's web services. Network tasks must run on a separate
	 * thread to ensure a responsive UI so the cover art lookup is carried out
	 * using this extension of Android's AsyncTask. In addition, AsyncTask
	 * provides the ability to make callbacks to the main thread for UI updates.
	 */
	class RecognizeFromMic implements GNSearchResultReady,
			GNOperationStatusChanged {

		/**
		 * Listen on microphone and fingerprint audio on separate thread.
		 */
		void doFingerprint() {
			GNOperations.recognizeMIDStreamFromMic(this, GracenoteMusicID.this.config);
		}

		/**
		 * When the record/fingeprint/lookup operation is finished, this method
		 * will be invoked in the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isFingerprintSearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, true, false);
				} else {
					if (config.getBooleanProperty("content.musicid.querypreference.singlebestmatch")) {
						GNSearchResponse bestResponse = result.getBestResponse();
						updateMetaDataFields(bestResponse, true, false);
						// Inserting search result into database.
						synchronized (result) {
							trackChanges(result);
						}
					} else {
						for (GNSearchResponse response : result.getResponses()) {
							updateMetaDataFields(response, true, false);
						}
					}
				}
				updateStatus("Success", true);
			}
			// Done with operation, enable the buttons again
			setUIEnabled(true);
		}

		/**
		 * Intermediate status update from the fingerprinter
		 */

		public void GNStatusChanged(GNStatus status) {
			if (status.getStatus() == GNStatusEnum.LISTENING) {
				String formatted = String.format("%s %d%s", status.getMessage(), status.getPercentDone(), "%");
				updateStatus(formatted, true);
			} else {
				updateStatus(status.getMessage(), true);
			}
		}
	}

	/**
	 * Implement Text Search with Artist/Album/Track combination.
	 */
	public class TextSearchTask implements GNSearchResultReady,
			GNOperationStatusChanged {

		public void textSearch(String artist, String album, String track) {
			GNOperations.searchByText(this, config, artist, album, track);
			listOfOperations.add((GNSearchResultReady) this);
		}

		/**
		 * When the fingeprint/lookup operation is finished, this method will be
		 * invoked in the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isAnySearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, false, true);
				} else {
					// Text search can return 0 to N responses
					for (GNSearchResponse response : result.getResponses()) {
						updateMetaDataFields(response, false, true);
					}
				}

				updateStatus("Success", true);
			}

			setUIEnabled(true);
		}

		/**
		 * Intermediate status update when webservices is contacted
		 */

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}
	}

	/**
	 * Implement Lyric Fragment Search with Artist and Lyric Fragment
	 * combination.
	 */
	public class LyricFragmentSearchTask implements GNSearchResultReady,
			GNOperationStatusChanged {

		public void lyricFragmentSearch(String artist, String lyricFragment) {
			GNOperations.searchByLyricFragment(this, config, lyricFragment,
					artist);
			listOfOperations.add((GNSearchResultReady) this);
		}

		/**
		 * When the fingeprint/lookup operation is finished, this method will be
		 * invoked in the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			listOfOperations.remove((GNSearchResultReady) this);
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isAnySearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, false, true);
				} else {
					// Lyric Fragment search can return 0 to N responses
					for (GNSearchResponse response : result.getResponses()) {
						updateMetaDataFields(response, false, true);
					}
				}

				updateStatus("Success", true);
			}

			setUIEnabled(true);
		}

		/**
		 * Intermediate status update when webservices is contacted
		 */

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}
	}

	/**
	 * Implement Track Search with TrackId combination. Because of
	 * un-availability of TrackId, currently AlbumId is passed. It is yet to
	 * change.
	 */
	public class TrackSearchTask implements GNSearchResultReady,
			GNOperationStatusChanged {

		public void trackSearch(String trackId) {
			GNOperations.fetchByTrackId(this, config, trackId);
			listOfOperations.add((GNSearchResultReady) this);
		}

		/**
		 * When the lookup operation is finished, this method will be invoked in
		 * the UI thread to report results.
		 */

		public void GNResultReady(GNSearchResult result) {
			listOfOperations.remove((GNSearchResultReady) this);
			if (result.isFailure()) {
				// An error occurred so display the error to the user.
				String msg = String.format("[%d] %s", result.getErrCode(),
						result.getErrMessage());
				updateStatus(msg, false); // Display error while leaving the
				// prior status update
			} else {
				if (result.isAnySearchNoMatchStatus()) {
					// Handle special case of webservices lookup with no match
					updateMetaDataFields((GNSearchResponse) null, false, false);
				} else {
					// Text search can return 0 to N responses
					for (GNSearchResponse response : result.getResponses()) {
						updateMetaDataFields(response, true, false);
					}
				}

				updateStatus("Success", true);
			}

			setUIEnabled(true);
		}

		/**
		 * Intermediate status update when webservices is contacted
		 */

		public void GNStatusChanged(GNStatus status) {
			updateStatus(status.getMessage(), true);
		}
	}

	/**
	 * 
	 * It will initiate the process to insert values into database.
	 * 
	 * @param row
	 *            - It contains all the information to be inserted into DB,
	 *            except location.
	 */
	private void trackChanges(GNSearchResult row) {
		GPSManager manager = new GPSManager(row, GracenoteMusicID.this);
		manager.retriveGPSInfo();
	}

	/**
	 * This method will insert GNSearchResult into database. It will be called
	 * after retrieving location.
	 * 
	 * @param row
	 *            - It will contain single GNSearchResult to update to result
	 * @param location
	 *            - It will contain location information to be inserted in
	 *            database.
	 */
	private void insertChanges(GNSearchResult row, Location location) {
		DatabaseAdapter db = new DatabaseAdapter(GracenoteMusicID.this);
		db.open();
		db.insertChanges(row, location);
		db.close();

	}

	/**
	 * 
	 * This class will find the GPS location and insert a row into database for
	 * history purpose.
	 * 
	 */
	class GPSManager implements LocationListener {
		LocationManager locationManager = null;
		GNSearchResult row = null;
		Timer gpsTimer = new Timer();
		Handler timerHandler = new Handler();
		boolean gpsTimeout = false;
		Context context;

		public GPSManager(GNSearchResult result, Context context) {
			this.row = result;
			this.context = context;
		}

		private void retriveGPSInfo() {
			String provider = Settings.Secure.getString(getContentResolver(),
					Settings.Secure.LOCATION_PROVIDERS_ALLOWED);

			Log.i("GN LocationManger", provider);
			if (provider == null || provider.equalsIgnoreCase("")) {
				insertChanges(row, null);
			} else {
				Criteria criteria = new Criteria();
				criteria.setAccuracy(Criteria.ACCURACY_FINE);
				criteria.setPowerRequirement(Criteria.POWER_MEDIUM);
				locationManager = (LocationManager) this.context
						.getSystemService(Context.LOCATION_SERVICE);
				locationManager.getBestProvider(criteria, true);
				locationManager.requestLocationUpdates(
						LocationManager.GPS_PROVIDER, 0, 0, this);
				gpsTimeout = false;
				gpsTimer.schedule(new GPSTimer(), 30 * 1000);
			}
		}

		private class GPSTimer extends TimerTask {
			private Runnable runnable = new Runnable() {
				public void run() {
					if (gpsTimeout == false) {
						Log.i("GPS", "Network GPS enabled...");
						gpsTimeout = true;
						locationManager.removeUpdates(GPSManager.this);
						Criteria criteria = new Criteria();
						criteria.setAccuracy(Criteria.ACCURACY_FINE);
						criteria.setPowerRequirement(Criteria.POWER_MEDIUM);
						locationManager = (LocationManager) GPSManager.this.context
								.getSystemService(Context.LOCATION_SERVICE);
						locationManager.getBestProvider(criteria, true);
						locationManager.requestLocationUpdates(
								LocationManager.NETWORK_PROVIDER, 0, 0,
								GPSManager.this);
						gpsTimer.schedule(new GPSTimer(), 30 * 1000);
					} else {
						// Precaution for not to insert duplicate entry into
						// database
						// Remove the timer so that all pending task will be
						// removed
						gpsTimer.cancel();
						gpsTimer.purge();
						gpsTimer = null;
						// //////////////////////////////////////////////////////////
						Log.i("GPS",
								"Timeout second time, inserting null values.");
						locationManager.removeUpdates(GPSManager.this);
						insertChanges(row, null);
					}
				}
			};

			@Override
			public void run() {
				timerHandler.post(runnable);
			}
		}

		/**
		 * 
		 * Called when the location has changed.
		 * 
		 * @param location
		 *            - new location
		 * 
		 */
		public void onLocationChanged(Location location) {
			// Precaution for not to insert duplicate entry into database
			// Remove the timer so that all pending task will be removed
			if (gpsTimer != null) {
				gpsTimer.cancel();
				gpsTimer.purge();
				gpsTimer = null;
			}
			Log.i("GPS", "Inside onLocationChanged()");
			locationManager.removeUpdates(GPSManager.this);
			System.out.println("GPSManager.onLocationChanged() Lat ="
					+ location.getLatitude() + " long = "
					+ location.getLongitude());
			insertChanges(this.row, location);
		}

		public void onProviderDisabled(String provider) {
			// Nothing to do at this stage.
		}

		public void onProviderEnabled(String provider) {
			// Nothing to do at this stage.
		}

		public void onStatusChanged(String provider, int status, Bundle extras) {
			// Nothing to do at this stage.
		}
	}

	protected void cancelAllOpertaions() {

		if (this.gNRecognizeStreamOperationTask != null) {
			this.gNRecognizeStreamOperationTask.cancelIdNow();
		}

		if (listOfOperations.size() > 0) {
			for (int i = 0; i < listOfOperations.size(); i++) {
				GNOperations.cancel(listOfOperations.get(i));
				listOfOperations.remove(i);
			}
		}
		updateStatus("Canceled", true);
		setUIEnabled(true);
	}


	private void updateResultScreenOnMainThread(GNSearchResult result) {

		MainThread mThread = new MainThread(result);
		this.runOnUiThread(mThread);
	}

	private void updateStatusOnMainThread(String message) {
		MainThread mThread = new MainThread(message);
		this.runOnUiThread(mThread);
	}
	
	private void updateStatusOnMainThread(GNStatus status) {
		MainThread mThread = new MainThread(status.getMessage());
		this.runOnUiThread(mThread);
	}

	private class MainThread implements Runnable {

		GNSearchResult result;
		String message;

		public MainThread(GNSearchResult inResult) {
			this.result = inResult;
			this.message = null;
		}

		public MainThread(String inMessage) {
			this.result = null;
			this.message = inMessage;
		}
		public void run() {

			if (this.message == null) {
				// Called with result
				if (this.result == null) {
					// Not possible condition. Returning from here..
					return;
				}

				if (result.isFailure()) {
					// An error occurred so display the error to the user.
					String msg = String.format("[%d] %s", result.getErrCode(), result.getErrMessage());
					updateStatus(msg, false); // Display error while leaving the
					// prior status update
				} else {
					if (result.isFingerprintSearchNoMatchStatus()) {
						// Handle special case of webservices lookup with no match
						updateMetaDataFields((GNSearchResponse) null, true, false);
					} else {
						if (config.getBooleanProperty("content.musicid.querypreference.singlebestmatch")) {
							GNSearchResponse bestResponse = result.getBestResponse();
							updateMetaDataFields(bestResponse, true, false);
							// Inserting search result into database.
							synchronized (result) {
								trackChanges(result);
							}
						} else {
							for (GNSearchResponse response : result.getResponses()) {
								updateMetaDataFields(response, true, false);
							}
						}
					}
					updateStatus("Success", true);
				}
				// Done with operation, enable the buttons again
				setUIEnabled(true);
			} else {
				// Called with status
				updateStatus(this.message, true);
			}
		}
	}
}
